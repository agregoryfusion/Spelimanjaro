<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Fast Math</title>
<style>
  :root{
    --bg:#0e0f12; --text:#ffffff; --muted:#a8b0bb; --accent:#1e90ff; --accent2:#00bfff; --panel:#161a20; --input:#15181d;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;text-align:center}
  h1{margin:18px 0 6px;color:var(--accent)}
  #version {  color: var(--accent);  font-size: 0.5em:  margin-top: -6px;}

  /* LOGIN */
  #login-screen{min-height:40vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:10px}
  #loginBtn{background:#0078d4;border:none;color:#fff;border-radius:8px;padding:12px 20px;font-size:16px;cursor:pointer}
  #loginBtn:hover{background:#005ea6}
  #loginStatus{color:#ff8a8a;font-size:13px}

  /* GAME */
  #game-container{display:none;max-width:900px;margin:0 auto;padding:10px 16px}
  #question{font-size:48px;font-weight:700;margin-top:80px;margin-bottom:30px;min-height:1.2em;transition:transform .05s}
  #timerBar{width:70%;height:30px;background:#20242b;border-radius:15px;margin:30px auto 30px;overflow:hidden;box-shadow:0 0 10px #1e90ff55}
  #timerFill{height:100%;background:linear-gradient(90deg, var(--accent), var(--accent2));width:100%}
  #answer{font-size:32px;padding:10px;border-radius:10px;border:2px solid var(--accent);width:140px;background:var(--input);color:#fff;text-align:center;outline:none;box-shadow:0 0 10px #1e90ff33;margin-bottom:16px}
  #answer:focus{border-color:var(--accent2);box-shadow:0 0 15px #00bfff55}
  #stage-info{margin-top:6px;font-size:18px;color:#c9d2db}

  /* END SCREEN */
  #end-screen{display:none;text-align:center;margin-top:60px;color:#fff}
  #end-screen h3{color:#ff4d4d;font-size:28px;margin:4px 0 10px}
  #end-screen p{margin:6px 0;font-size:18px}
  #end-screen button{background:var(--accent);border:none;color:#fff;padding:10px 20px;font-size:16px;border-radius:8px;margin:10px;cursor:pointer;transition:filter .2s}
  #end-screen button:hover{filter:brightness(1.05)}
  #session-id{color:#99a6b4;font-size:14px}
  #saved-status{color:#7fdca2;font-size:14px}

  /* LEADERBOARD */
  #leaderboardContainer{display:none;margin:40px auto 20px;max-width:800px;text-align:center;opacity:0;transition:opacity .3s}
  #leaderboardContainer.show{opacity:1}
  #leaderboardStatus{color:#cfd6de;font-size:14px}
  #leaderboardContainer table{width:100%;border-collapse:collapse;margin-top:12px}
  #leaderboardContainer th,#leaderboardContainer td{padding:10px;border-bottom:1px solid #2a2f37;text-align:center}
  #leaderboardContainer th{color:var(--accent);font-weight:600;border-bottom:2px solid #1e90ff33}
  #leaderboardContainer td{color:#e6e9ee}
  #leaderboardContainer tr:hover td{background:#1e90ff22}
</style>
</head>
<body>
  <h1>Fusion Fast Math</h1>
<p id="version">v1.0.25</p>
  <!-- Sign-In Screen -->
  <div id="login-screen">
    <p class="note" style="color:#c9d2db">Please sign in with your Microsoft account to continue.</p>
    <button id="loginBtn">Sign in with Microsoft</button>
    <div id="loginStatus"></div>
  </div>

  <!-- Game -->
  <div id="game-container">
    <div id="question"></div>
    <div id="timerBar"><div id="timerFill"></div></div>
    <input id="answer" type="text" autocomplete="off" inputmode="numeric" placeholder="?" />
    <div id="stage-info"></div>
  </div>

  <!-- End Screen -->
  <div id="end-screen">
    <h3>Game Over</h3>

    <p id="end-questions">Questions answered: —</p>
    <p id="end-penalty">Total penalty time: — s</p>
    <p id="end-total">Total time: — s (<span id="end-with-penalty">—</span> s with penalties)</p>
    <p id="end-avg">Avg time/question: — s (<span id="end-avg-with-penalty">—</span> s with penalties)</p>

    <p id="session-id"></p>
    <p id="saved-status"></p>

    <button id="restartBtn">Restart</button>
<div id="leaderboardButtons">
  <button id="viewAllBtn">Everyone</button>
  <button id="viewStudentsBtn">Students</button>
  <button id="viewTeachersBtn">Teachers</button>
</div>

    <div id="leaderboardContainer">
      <p id="leaderboardStatus"></p>
      <table>
        <thead>
          <tr>
            <th>#</th><th>Player</th><th>Questions</th><th>Time (s)</th><th>Date</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Firebase + Auth + Game -->
  <script type="module">
    /* ===================== Firebase SDKs ===================== */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
    import {
      getAuth, OAuthProvider, signInWithPopup,
      setPersistence, browserLocalPersistence, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
    import {
      getFirestore, collection, doc, setDoc, addDoc,
      getDocs, query, orderBy, limit
    } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

    /* ===================== Config (fill this in) ===================== */
const firebaseConfig = {
  apiKey: "AIzaSyBUaOrUckCuTrc9MHB9jCF4TUsx-hWFC7g",
  authDomain: "ironmath-1263b.firebaseapp.com",
  projectId: "ironmath-1263b",
  storageBucket: "ironmath-1263b.firebasestorage.app",
  messagingSenderId: "729878130193",
  appId: "1:729878130193:web:f4d447b552e4f955f80bb0",
  measurementId: "G-0VCM7C1HPC"
};
    /* ===================== Init ===================== */
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new OAuthProvider("microsoft.com");
    await setPersistence(auth, browserLocalPersistence);

    /* ===================== DOM ===================== */
    const loginScreen = document.getElementById("login-screen");
    const loginBtn = document.getElementById("loginBtn");
    const loginStatus = document.getElementById("loginStatus");
    const gameContainer = document.getElementById("game-container");
    const endScreen = document.getElementById("end-screen");
    const questionEl = document.getElementById("question");
    const answerEl = document.getElementById("answer");
    const stageInfo = document.getElementById("stage-info");
    const timerFill = document.getElementById("timerFill");
    const restartBtn = document.getElementById("restartBtn");
    const viewAllBtn = document.getElementById("viewAllBtn");
    const viewStudentsBtn = document.getElementById("viewStudentsBtn");
    const viewTeachersBtn = document.getElementById("viewTeachersBtn");
    const lbWrap = document.getElementById("leaderboardContainer");
    const lbStatus = document.getElementById("leaderboardStatus");
    const lbBody = document.querySelector("#leaderboardContainer tbody");

    /* ===================== Auth Flow ===================== */
    function parseEmailToName(email){
      if(!email) return "Player";
      const local = email.split("@")[0];
      const parts = local.split(/[._-]+/).filter(Boolean);
      if(parts.length >= 2) return parts.map(cap).join(" ");
      return cap(local);
    }
    const cap = s => s ? s.charAt(0).toUpperCase() + s.slice(1) : s;
    let playerName = "Player";

let isTeacher = false;
let isStudent = false;

onAuthStateChanged(auth, (user) => {
  if (user) {
    playerName = user.displayName || parseEmailToName(user.email);

    const email = user.email?.toLowerCase() || "";
    if (email.endsWith("@fusionacademy.com")) {
      isTeacher = true;
      isStudent = false;
    } else if (email.endsWith("@fusionacademy.me")) {
      isStudent = true;
      isTeacher = false;
    } else {
      isTeacher = false;
      isStudent = false;
    }

    loginScreen.style.display = "none";
    endScreen.style.display = "none";
    gameContainer.style.display = "block";
    startGame();
  } else {
    gameContainer.style.display = "none";
    endScreen.style.display = "none";
    loginScreen.style.display = "flex";
  }
});

loginBtn.addEventListener("click", async ()=>{
  try{
    const result = await signInWithPopup(auth, provider);
    const u = result.user;
    playerName = u.displayName || parseEmailToName(u.email);

    const email = u.email?.toLowerCase() || "";
    if (email.endsWith("@fusionacademy.com")) {
      isTeacher = true;
      isStudent = false;
    } else if (email.endsWith("@fusionacademy.me")) {
      isStudent = true;
      isTeacher = false;
    } else {
      isTeacher = false;
      isStudent = false;
    }

    loginScreen.style.display = "none";
    gameContainer.style.display = "block";
    startGame();
  }catch(e){
    console.error("Sign-in error:", e);
    loginStatus.textContent = "Sign-in failed: " + (e?.message || e);
  }
});


    /* ===================== Game Settings ===================== */
    const SIGMA_SCALE = 6;       // normal distribution width across product range
    const STRETCH_MULT = 0.5;    // one factor may stretch up to stage*(1+STRETCH_MULT)
    const WEIGHT_DECAY = 0.88;   // repeat product decay factor
    const WEIGHT_STRENGTH = 4;   // how strongly repeats are penalized
    const START_STAGE = 8;
    const TIMER_SECONDS = 10;
    const DUPLICATE_PROTECTION = 25;
    const PENALTY_MULT = 2;      // per-digit penalty multiplier (1x,2x,4x...) per question

    /* ===================== Game State ===================== */
    let sessionId = buildSessionID(playerName);
    let stage = START_STAGE;
    let questionCount = 0;   // total asked (for stage growth)
    let correctCount = 0;
    let totalTimeTrue = 0;   // sum of actual per-question solve times
    let penaltySeconds = 0;  // sum of penalties
    let productWeights = {}; // product -> weight
    let recentAnswers = [];  // last N products for duplicate protection
    let current = null;      // {a,b,prod}
    let timeLeft = TIMER_SECONDS;
    let rafId = 0;
    let qStartTs = 0;        // question start perf.now()
    let runStartTs = 0;      // run start perf.now()
    let mistakesThisQuestion = 0;
    let loggedThisQuestion = false;

    /* ===================== Helpers ===================== */
    function shortID(len=6){
      const chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let out=''; for(let i=0;i<len;i++) out += chars[Math.floor(Math.random()*chars.length)];
      return out;
    }
    function randn(){ let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }
    function sampleTrunc(minV,maxV,mu,sigma){
      if(sigma<=0||!isFinite(sigma)) return Math.min(Math.max(mu,minV),maxV);
      for(let i=0;i<40;i++){ const x=mu+sigma*randn(); if(x>=minV && x<=maxV) return x; }
      return Math.min(Math.max(mu,minV),maxV);
    }
    function buildPairs(stage){
      const maxF = Math.floor(stage*(1+STRETCH_MULT));
      const out=[];
      for(let a=1;a<=maxF;a++){
        for(let b=1;b<=maxF;b++){
          if(a>stage && b>stage) continue; // allow stretching on only one factor
          out.push([a,b]);
        }
      }
      return out;
    }
    function choosePair(pairs){
      let minP=Infinity,maxP=-Infinity;
      const prods=new Array(pairs.length);
      for(let i=0;i<pairs.length;i++){ const p=pairs[i][0]*pairs[i][1]; prods[i]=p;
        if(p<minP)minP=p; if(p>maxP)maxP=p; }
      const mu=(minP+maxP)/2;
      const sigma=Math.max(1e-6,(maxP-minP)/SIGMA_SCALE);
      const target=sampleTrunc(minP,maxP,mu,sigma);

      let bestIdx=-1,bestScore=Infinity,safety=0;
      while(safety++<500){
        for(let i=0;i<pairs.length;i++){
          const p=prods[i];
          if(recentAnswers.includes(p)) continue;
          const dist=Math.abs(p-target);
          const w=(productWeights[p]||0);
          const score = dist * (1 + WEIGHT_STRENGTH*w);
          if(score<bestScore){ bestScore=score; bestIdx=i; }
        }
        if(bestIdx!==-1) break;
        // If everything excluded by recent list, relax by popping oldest
        recentAnswers.shift();
      }
      const [a,b]=pairs[bestIdx];
      return {a,b,prod:a*b};
    }
    function decayWeightsAndBump(prod){
      for(const k in productWeights){
        productWeights[k]*=WEIGHT_DECAY;
        if(productWeights[k] < 1e-4) delete productWeights[k];
      }
      productWeights[prod]=(productWeights[prod]||0)+1;
    }
    function shake(el, mult=1){
      const urgency = 1 - (timeLeft/TIMER_SECONDS);         // more shake when time is low
      const dur = 0.3 + 0.2*urgency;
      const base = 8;
      const mag = base * (1 + 2*urgency) * (1 + 0.3*(mult-1));
      const t0 = performance.now();
      (function step(){
        const dt = performance.now()-t0;
        if(dt < dur*1000){
          const k = 1 - dt/(dur*1000);
          const vertBias = 0.5 + 1.5*urgency;
          const dx=(Math.random()*2-1)*mag*k;
          const dy=(Math.random()*2-1)*mag*k*vertBias;
          el.style.transform=`translate(${dx}px,${dy}px)`;
          requestAnimationFrame(step);
        }else{
          el.style.transform='translate(0,0)';
        }
      })();
    }

    /* ===================== Game Flow ===================== */
let runData = { sessionID: "", results: [] };
    
function buildSessionID(playerName) {
  const parts = (playerName || "Player").trim().split(/\s+/);
  const first = parts[0] || "Player";
  const last = parts[1] || "";

  // Get MST (UTC−7)
  const now = new Date();
  const utcMs = now.getTime() + now.getTimezoneOffset() * 60000;
  const mst = new Date(utcMs - 7 * 60 * 60000);

  // Format safe date string (no slashes)
  const mm = String(mst.getMonth() + 1).padStart(2, "0");
  const dd = String(mst.getDate()).padStart(2, "0");
  const yyyy = mst.getFullYear();
  const hh = String(mst.getHours()).padStart(2, "0");
  const min = String(mst.getMinutes()).padStart(2, "0");

  // Use dashes instead of slashes
  return `${first} ${last} ${mm}-${dd}-${yyyy} ${hh}:${min}`;
}


function resetRunState() {
  sessionId = buildSessionID(playerName);
  runData = { sessionID: sessionId, results: [] }; // add this line
  stage = START_STAGE;
  questionCount = 0;
  correctCount = 0;
  totalTimeTrue = 0;
  penaltySeconds = 0;
  productWeights = {};
  recentAnswers = [];
  mistakesThisQuestion = 0;
  loggedThisQuestion = false;
  timeLeft = TIMER_SECONDS;
  cancelAnimationFrame(rafId);
}

    function startGame(){
      resetRunState();
      runStartTs = performance.now();
      nextQuestion();
    }

    function nextQuestion(){
      // decay and pick a new pair not in recent
      const pairs = buildPairs(stage);
      let q; let guard=0;
      do{
        q = choosePair(pairs);
        guard++; if(guard>1000) break;
      }while(recentAnswers.includes(q.prod));
      recentAnswers.push(q.prod);
      if(recentAnswers.length > DUPLICATE_PROTECTION) recentAnswers.shift();
      current = q;
      mistakesThisQuestion = 0;
      loggedThisQuestion = false;

      questionEl.textContent = `${q.a} × ${q.b}`;
      answerEl.value = "";
      answerEl.focus();
      stageInfo.textContent = `Stage ${stage}`;

      // timer start
      let penaltySecondsThisRound = 0;
      timeLeft = TIMER_SECONDS;
      qStartTs = performance.now();
      timerFill.style.width = "100%";
      cancelAnimationFrame(rafId);

      const tick = () => {
        const elapsed = (performance.now() - qStartTs) / 1000;
        const remaining = TIMER_SECONDS - elapsed - penaltySecondsThisRound;
        timeLeft = Math.max(0, remaining);

        const pct = Math.max(0, Math.min(1, timeLeft / TIMER_SECONDS));
        timerFill.style.width = (pct * 100) + "%";

        if (timeLeft <= 0) {
         // if (!loggedThisQuestion) {
            const trueT = (performance.now() - qStartTs) / 1000;
            totalTimeTrue += trueT;
          runData.results.push({
  a: current.a,
  b: current.b,
  stage,
  timeTaken: (performance.now() - qStartTs) / 1000,
  mistakes: mistakesThisQuestion,
  success: false
});
          //}
          return gameOver();
        }
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);

      // attach a local handler that can see penaltySecondsThisRound
      answerEl.oninput = (e)=>{
        if(!current) return;
        const val = e.target.value.trim();
        if(val === "") return;
        const correctStr = String(current.prod);

        if(val === correctStr){
          // correct
          const trueT = (performance.now()-qStartTs)/1000;
          totalTimeTrue += trueT;
          correctCount++;
          questionCount++;
          runData.results.push({
  a: current.a,
  b: current.b,
  stage,
  timeTaken: (performance.now() - qStartTs) / 1000,
  mistakes: mistakesThisQuestion,
  success: true
});
          decayWeightsAndBump(current.prod);
          // Stage growth (quadratic-like)
          const stepSize = 2*stage - 1;
          if(questionCount >= stepSize*(stage-START_STAGE+1)) stage++;
          current = null;
          return nextQuestion();
        }

        // wrong digit (not a prefix)
        if(!correctStr.startsWith(val)){
          const avgModifiedSoFar = (totalTimeTrue + penaltySeconds) / Math.max(correctCount, 1) || 2.0;
          const penalty = avgModifiedSoFar * Math.pow(PENALTY_MULT, mistakesThisQuestion); // 1x,2x,4x...
          mistakesThisQuestion++;
        //  runData.results.push({  a: current.a,  b: current.b,  stage,  timeTaken: (performance.now() - qStartTs) / 1000,  mistakes: mistakesThisQuestion,  success: false});
          penaltySeconds += penalty;            // counted in modified totals
          penaltySecondsThisRound += penalty;   // affects visible time-left this question

          // visually jump bar and undo last digit
          const remaining = TIMER_SECONDS - ((performance.now() - qStartTs) / 1000) - penaltySecondsThisRound;
          timeLeft = Math.max(0, remaining);
          const pct = Math.max(0, Math.min(1, timeLeft / TIMER_SECONDS));
          timerFill.style.width = (pct * 100) + "%";

          e.target.value = val.slice(0, -1);
          shake(questionEl, mistakesThisQuestion);

          if (remaining <= 0) {
                      runData.results.push({  a: current.a,  b: current.b,  stage,  timeTaken: (performance.now() - qStartTs) / 1000,  mistakes: mistakesThisQuestion,  success: false});
            return gameOver();}
        }
      };
    }

    function gameOver(){
      cancelAnimationFrame(rafId);
      current = null;
      gameContainer.style.display = "none";
      endScreen.style.display = "block";


      // ✅ Show leaderboard immediately
      lbWrap.style.display = "block";
      lbWrap.classList.add("show");
      lbStatus.textContent = "Loading leaderboard...";
      loadLeaderboard("all", true); // default to 'all' filter

      const totalTrue = totalTimeTrue;
      const totalWithPen = totalTimeTrue + penaltySeconds;
      const avgTrue = totalTrue / Math.max(correctCount,1);
      const avgPen = totalWithPen / Math.max(correctCount,1);

     /* document.getElementById("end-stage").textContent = `Stage reached: ${stage}`;*/
      document.getElementById("end-questions").textContent = `Questions answered: ${correctCount}`;
      document.getElementById("end-penalty").textContent = `Total penalty time: ${penaltySeconds.toFixed(2)} s`;
      document.getElementById("end-total").innerHTML =
        `Total time: ${totalTrue.toFixed(2)} s (<span id="end-with-penalty">${totalWithPen.toFixed(2)}</span> s with penalties)`;
      document.getElementById("end-avg").innerHTML =
        `Avg time/question: ${avgTrue.toFixed(2)} s (<span id="end-avg-with-penalty">${avgPen.toFixed(2)}</span> s with penalties)`;
     /* document.getElementById("session-id").textContent = `Session ID: ${sessionId}`; */
  // If player ran out of time mid-question, log that as a failed entry

      uploadSession(totalTrue);
    }

    // Restart (keep auth)
    restartBtn.addEventListener("click", ()=>{
      endScreen.style.display = "none";
      gameContainer.style.display = "block";
      startGame();
    });

    /* ===================== Uploads + Leaderboard ===================== */
async function uploadSession(totalTrue) {
  try {
const payload = {
  sessionID: sessionId,
  playerName,
  stageReached: stage,
  totalTime: totalTrue,
  penaltyTime: penaltySeconds,
  questionsAnswered: correctCount,
  dateAdded: Date.now(),
  isTeacher,
  isStudent
};

    const answersArray = runData.results.map(q => ({
      a: q.a,
      b: q.b,
      stage: q.stage,
      timeTaken: q.timeTaken,
      mistakes: q.mistakes,
      success: q.success,
      dateAdded: Date.now()
    }));

    const sessionRef = doc(collection(db, "sessions"), sessionId);
    await setDoc(sessionRef, { ...payload, answers: answersArray }, { merge: false });

    // Add leaderboard summary (unchanged)
await addDoc(collection(db, "leaderboard"), payload);

// ✅ Update the local cache immediately
updateCachedLeaderboardWithNewScore(payload);

document.getElementById("saved-status").textContent = "Saved ✓";
  } catch (e) {
    console.error("Upload failed", e);
    const s = document.getElementById("saved-status");
    s.textContent = "Upload failed";
    s.style.color = "#ff8a8a";
  }
}


function showLeaderboard(filteredData = null) {
  const showing = lbWrap.classList.toggle("show");
  lbWrap.style.display = showing ? "block" : "none";
  if (showing) {
    loadLeaderboard(filteredData);
  }
}

viewAllBtn.addEventListener("click", () => renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData, "all")));
viewStudentsBtn.addEventListener("click", () => renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData, "students")));
viewTeachersBtn.addEventListener("click", () => renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData, "teachers")));


// Caching variables
let cachedLeaderboardData = null;
let lastLeaderboardFetchTime = 0;
const LEADERBOARD_CACHE_DURATION = 60000; // 60 seconds
function updateCachedLeaderboardWithNewScore(newEntry) {
  if (!newEntry?.playerName) return;

  const key = (newEntry.playerName || "").trim().toLowerCase();
  if (!cachedLeaderboardData) cachedLeaderboardData = [];

  // Check if this player already exists in cache
  const existingIndex = cachedLeaderboardData.findIndex(
    d => (d.playerName || "").trim().toLowerCase() === key
  );

  if (existingIndex !== -1) {
    const old = cachedLeaderboardData[existingIndex];

    // Replace only if the new one is better
    const isBetter =
      newEntry.questionsAnswered > (old.questionsAnswered ?? 0) ||
      (newEntry.questionsAnswered === old.questionsAnswered &&
        newEntry.totalTime < (old.totalTime ?? Infinity));

    if (isBetter) {
      cachedLeaderboardData[existingIndex] = newEntry;
    }
  } else {
    // First time this player has ever appeared
    cachedLeaderboardData.push(newEntry);
  }

  // Sort the cache again by leaderboard rules
  cachedLeaderboardData.sort((a, b) => {
    if (b.questionsAnswered === a.questionsAnswered)
      return a.totalTime - b.totalTime;
    return b.questionsAnswered - a.questionsAnswered;
  });

  // Re-render immediately using whatever filter is active
  const activeFilter =
    document.querySelector("#leaderboardButtons button.active")?.id || "allBtn";
  const filterType =
    activeFilter.includes("student")
      ? "students"
      : activeFilter.includes("teacher")
      ? "teachers"
      : "all";

  renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData, filterType));
}

async function loadLeaderboard(filterType = "all", forceRefresh = false) {
  try {
    const now = Date.now();
    if (!forceRefresh && cachedLeaderboardData && (now - lastLeaderboardFetchTime < LEADERBOARD_CACHE_DURATION)) {
      console.log("Using cached leaderboard data");
      renderLeaderboard(applyLeaderboardFilter(cachedLeaderboardData, filterType));
      return;
    }

    lbStatus.textContent = "Loading leaderboard...";
    const qy = query(
      collection(db, "leaderboard"),
      orderBy("questionsAnswered", "desc"),
      orderBy("totalTime", "asc"),
      limit(500)
    );
    const snap = await getDocs(qy);

    const grouped = {};
    snap.forEach(docSnap => {
      const d = docSnap.data();
      if (!d.playerName) return;
      const key = (d.playerName || "").trim().toLowerCase();
      if (!grouped[key]) grouped[key] = [];
      grouped[key].push(d);
    });

    const best = Object.values(grouped).map(list =>
      list.sort((a, b) => {
        if (b.questionsAnswered === a.questionsAnswered)
          return a.totalTime - b.totalTime;
        return b.questionsAnswered - a.questionsAnswered;
      })[0]
    );

    best.sort((a, b) => {
      if (b.questionsAnswered === a.questionsAnswered)
        return a.totalTime - b.totalTime;
      return b.questionsAnswered - a.questionsAnswered;
    });

    cachedLeaderboardData = best;
    lastLeaderboardFetchTime = now;

    renderLeaderboard(applyLeaderboardFilter(best, filterType));
    lbStatus.textContent = "";
  } catch (e) {
    console.error(e);
    lbStatus.textContent = "Failed to load leaderboard: " + (e?.message || e);
  }
}
function applyLeaderboardFilter(data, filterType) {
  if (filterType === "students") {
    return data.filter(d => d.isStudent === true);
  } else if (filterType === "teachers") {
    return data.filter(d => d.isTeacher === true);
  }
  return data;
}

function renderLeaderboard(data) {
  lbBody.innerHTML = "";
  let rank = 1;
  for (const d of data.slice(0, 100)) {
    const date = d.dateAdded ? new Date(d.dateAdded) : null;
    const mm = date ? String(date.getMonth() + 1).padStart(2, "0") : "--";
    const dd = date ? String(date.getDate()).padStart(2, "0") : "--";
    const yyyy = date ? date.getFullYear() : "----";

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${rank++}</td>
      <td>${escapeHtml(d.playerName || "???")}</td>
      <td>${d.questionsAnswered ?? "?"}</td>
      <td>${(d.totalTime ?? 0).toFixed(2)}</td>
      <td>${mm}/${dd}/${yyyy}</td>
    `;
    lbBody.appendChild(tr);
  }
}

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
    }
  </script>
</body>
</html>
